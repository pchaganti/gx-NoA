<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Deep Think</title>
    <script src="js/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="css/prism-okaidia.min.css">
    <link rel="stylesheet" href="css/prism-toolbar.min.css">
    <style>
        :root {
            --primary-color: #0E1117;
            --secondary-color: #262730;
            --accent-color: #FF4B4B;
            --text-color: #FAFAFA;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            --border-radius: 0.5rem;
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 2rem;
            font-size: 16px;
            line-height: 1.6;
        }

        h1,
        h2 {
            color: var(--text-color);
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 0.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            border-bottom: none;
        }

        h2 {
            font-size: 1.75rem;
        }

        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: var(--primary-color);
            padding: 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
        }

        .section {
            background-color: var(--secondary-color);
            padding: 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
        }

        .hidden {
            display: none;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        input,
        textarea,
        button,
        select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid var(--secondary-color);
            background-color: #1C1E25;
            color: var(--text-color);
            border-radius: var(--border-radius);
            box-sizing: border-box;
            font-family: inherit;
            font-size: 1rem;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(255, 75, 75, 0.3);
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        button {
            cursor: pointer;
            background-color: var(--accent-color);
            color: var(--text-color);
            font-weight: bold;
            border: none;
            transition: background-color 0.3s ease;
        }

        button:hover:not(:disabled) {
            background-color: #E03C3C;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #log-container {
            height: 400px;
            background-color: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            overflow-y: scroll;
            font-family: 'Menlo', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            color: #C0C0C0;
            white-space: pre-wrap;
        }

        #graph-container {
            min-height: 400px;
            background-color: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Menlo', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            color: #C0C0C0;
            white-space: pre;
        }

        #graph-container p {
            color: #888;
            white-space: pre-wrap;
        }

        .mbti-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
            background-color: #1C1E25;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
        }

        .mbti-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mbti-option input[type="checkbox"] {
            width: auto;
            margin-bottom: 0;
        }

        .mbti-option label {
            margin-bottom: 0;
            font-weight: normal;
        }

        #results-container pre,
        #hidden-outputs-container pre,
        #papers-container pre,
        #code-result-container pre,
        #modules-container pre {
            background-color: #000;
            padding: 1rem;
            border-radius: var(--border-radius);
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #FAFAFA;
        }

        .header-with-button {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .header-with-button h2,
        .header-with-button h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin: 0;
        }

        #download-log-button,
        .download-paper-button,
        #download-report-button,
        #export-qnn-button {
            width: auto;
            padding: 0.5rem 1rem;
            margin-bottom: 0;
            font-size: 0.9rem;
            background-color: var(--secondary-color);
        }

        #download-log-button:hover:not(:disabled),
        .download-paper-button:hover:not(:disabled),
        #download-report-button:hover:not(:disabled),
        #export-qnn-button:hover:not(:disabled) {
            background-color: #3a3b44;
        }

        .chat-messages {
            height: 400px;
            background-color: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-message {
            padding: 0.75rem 1rem;
            border-radius: var(--border-radius);
            max-width: 80%;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .user-message {
            background-color: var(--accent-color);
            color: var(--text-color);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }

        .ai-message {
            background-color: var(--secondary-color);
            color: var(--text-color);
            align-self: flex-start;
            border-bottom-left-radius: 0;
            white-space: pre-wrap;
        }

        #chat-form,
        #diagnostic-chat-form {
            display: flex;
            gap: 1rem;
        }

        #chat-input,
        #diagnostic-chat-input {
            flex-grow: 1;
            min-height: 50px;
            height: 50px;
            margin-bottom: 0;
            resize: none;
        }

        #chat-send-button,
        #diagnostic-chat-send-button {
            width: auto;
            margin-bottom: 0;
            align-self: flex-end;
        }

        #harvest-button {
            width: auto;
            padding: 0.5rem 1.5rem;
            margin-bottom: 0;
            font-size: 1rem;
            font-weight: bold;
            background-color: #28a745;
        }

        #harvest-button:hover:not(:disabled) {
            background-color: #218838;
        }

        #diagnostic-chat-container {
            border: 2px solid #007bff;
        }

        #diagnostic-chat-container h2 {
            color: #00aaff;
            border-bottom-color: #007bff;
        }

        .diagnostic-ai-message {
            background-color: #1c2e4a;
            color: #e0e0ff;
            align-self: flex-start;
            border-bottom-left-radius: 0;
            white-space: pre-wrap;
        }

        .diagnostic-user-message {
            background-color: #0056b3;
            color: var(--text-color);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }

        .qnn-import-section {
            border: 2px dashed var(--accent-color);
            padding: 1.5rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .qnn-import-section label {
            cursor: pointer;
            background-color: var(--secondary-color);
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius);
            display: inline-block;
            margin-bottom: 1rem;
        }

        .qnn-import-section input[type="file"] {
            display: none;
        }

        #imported-qnn-info {
            background-color: #1c2e4a;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-top: 1rem;
            text-align: left;
        }

        #inference-options {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }

        #inference-options button {
            background-color: #007bff;
            width: 50%;
        }

        #inference-options button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        /* Mode Tabs */
        .mode-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--secondary-color);
        }

        .mode-tab {
            padding: 1rem 2rem;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }

        .mode-tab:hover {
            color: var(--text-color);
            background: rgba(255, 255, 255, 0.05);
        }

        .mode-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
        }

        /* Settings Panel */
        .settings-panel {
            background: linear-gradient(145deg, #1a1d24, #22252e);
            border: 1px solid var(--secondary-color);
            padding: 1rem 1.5rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .settings-panel label {
            margin: 0;
            font-weight: 600;
            color: #aaa;
        }

        .settings-panel input {
            flex: 1;
            min-width: 200px;
            margin: 0;
        }

        .settings-panel button {
            width: auto;
            padding: 0.5rem 1.5rem;
            margin: 0;
        }

        .api-key-status {
            color: #28a745;
            font-size: 0.9rem;
        }

        /* Brainstorming Mode */
        .brainstorm-container {
            display: none;
        }

        .brainstorm-container.active {
            display: block;
        }

        .algorithm-container.hidden {
            display: none;
        }

        .expert-panel {
            background: linear-gradient(145deg, #1c2030, #252a38);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .expert-panel h3 {
            margin: 0 0 0.75rem 0;
            color: var(--accent-color);
            border-bottom: none;
        }

        .expert-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .expert-badge {
            background: rgba(255, 255, 255, 0.08);
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .expert-badge .specialty {
            color: #888;
            font-size: 0.75rem;
        }

        .brainstorm-chat {
            background: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            height: 450px;
            overflow-y: auto;
            padding: 1rem;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .expert-message {
            background: linear-gradient(145deg, #1a2940, #1e3355);
            border-radius: var(--border-radius);
            padding: 1rem;
            border-left: 3px solid #007bff;
        }

        .expert-message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .expert-message-header .specialty {
            color: #888;
            font-weight: normal;
            font-size: 0.85rem;
        }

        .synthesis-message {
            background: linear-gradient(145deg, #2d3a2d, #354535);
            border-radius: var(--border-radius);
            padding: 1rem;
            border-left: 3px solid #28a745;
        }

        .synthesis-message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #28a745;
        }

        .thinking-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #888;
            font-style: italic;
        }

        .thinking-dots {
            display: inline-flex;
            gap: 2px;
        }

        .thinking-dots span {
            width: 6px;
            height: 6px;
            background: var(--accent-color);
            border-radius: 50%;
            animation: thinking 1.4s ease-in-out infinite;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes thinking {

            0%,
            80%,
            100% {
                opacity: 0.3;
                transform: scale(0.8);
            }

            40% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .brainstorm-input-form {
            display: flex;
            gap: 1rem;
        }

        .brainstorm-input-form textarea {
            flex: 1;
            min-height: 60px;
            margin: 0;
            resize: none;
        }

        .brainstorm-input-form button {
            width: auto;
            align-self: flex-end;
        }
    </style>
</head>

<body>
    <h1>It takes a village of agents to raise an agent</h1>

    <!-- Settings Panel -->
    <div class="container">
        <div class="settings-panel" style="flex-wrap: wrap;">
            <label for="llm-provider">ðŸ¤– LLM Provider:</label>
            <select id="llm-provider"
                style="padding: 0.5rem; border-radius: 4px; background: #1a1d24; color: #fff; border: 1px solid #333;">
                <option value="gemini">Gemini (Cloud)</option>
                <option value="grok">Grok (xAI)</option>
                <option value="ollama">Ollama (Local)</option>
            </select>

            <div id="gemini-config" style="display: flex; gap: 0.5rem; align-items: center;">
                <label for="gemini-api-key">ðŸ”‘ API Key:</label>
                <input type="password" id="gemini-api-key" placeholder="Gemini API key..." style="min-width: 180px;">
            </div>

            <div id="grok-config" style="display: none; gap: 0.5rem; align-items: center;">
                <label for="grok-api-key">ðŸŒŒ API Key:</label>
                <input type="password" id="grok-api-key" placeholder="Grok API key..." style="min-width: 180px;">
            </div>

            <div id="ollama-config" style="display: none; gap: 0.5rem; align-items: center;">
                <label for="ollama-model-global">ðŸ“¦ Model:</label>
                <input type="text" id="ollama-model-global" value="dengcao/Qwen3-30B-A3B-Instruct-2507:latest"
                    placeholder="Ollama model..." style="min-width: 250px;">
            </div>

            <button type="button" id="save-api-key-btn">Save</button>
            <span id="api-key-status" class="api-key-status"></span>
        </div>
    </div>

    <!-- Mode Tabs -->
    <div class="container">
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="algorithm">ðŸ§¬ Algorithm Design Mode</button>
            <button class="mode-tab" data-mode="brainstorm">ðŸ§  Brainstorming Mode</button>
        </div>
    </div>

    <!-- Brainstorming Mode Container -->
    <div class="container brainstorm-container" id="brainstorm-mode">
        <div class="section">
            <h2>ðŸ§  Brainstorming Mode</h2>
            <p>Chat with a panel of AI experts who will reflect on your ideas from different perspectives.</p>

            <div class="brainstorm-chat" id="brainstorm-chat">
                <div style="color: #666; text-align: center; padding: 2rem;">
                    Ask a question or share an idea to get started...
                </div>
            </div>

            <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <label for="brainstorm_epochs" style="color: #aaa; font-size: 0.9rem;">Epochs:</label>
                    <input type="number" id="brainstorm_epochs" value="2" min="1" max="10"
                        style="width: 50px; padding: 4px; border-radius: 4px; border: 1px solid #444; background: #222; color: #eee;">
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="brainstorm_debug_mode">
                    <label for="brainstorm_debug_mode" style="color: #aaa; cursor: pointer; font-size: 0.9rem;">ðŸš€
                        Simulation Mode (Mock LLM - No Cost)</label>
                </div>
            </div>

            <!-- PDF Upload Section -->
            <div id="pdf-upload-section"
                style="margin-bottom: 15px; padding: 1rem; background: #1a1d24; border-radius: 8px; border: 1px dashed #444;">
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <label for="pdf-file-input"
                        style="cursor: pointer; background: #262730; padding: 8px 16px; border-radius: 6px; display: flex; align-items: center; gap: 6px; font-size: 0.9rem;">
                        ðŸ“„ Attach PDFs
                    </label>
                    <input type="file" id="pdf-file-input" accept=".pdf" multiple style="display: none;">
                    <span id="pdf-upload-status" style="color: #888; font-size: 0.85rem;"></span>
                    <button type="button" id="clear-pdfs-btn"
                        style="display: none; background: #444; padding: 6px 12px; border-radius: 4px; font-size: 0.8rem; width: auto;">Clear
                        All</button>
                </div>
                <div id="attached-documents-list" style="margin-top: 10px; display: none;">
                    <div style="font-size: 0.85rem; color: #888; margin-bottom: 6px;">Attached Documents:</div>
                    <div id="documents-list" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>
            </div>

            <form class="brainstorm-input-form" id="brainstorm-form">
                <textarea id="brainstorm-input" placeholder="What would you like to brainstorm?" required></textarea>
                <button type="submit" id="brainstorm-send-btn">Send</button>
            </form>
        </div>
    </div>

    <!-- Algorithm Design Mode Container -->
    <div class="algorithm-container" id="algorithm-mode">
        <div class="container">
            <div id="qnn-import-container" class="section qnn-import-section">
                <h2>Load a Pre-Trained QNN</h2>
                <p>Import a previously exported QNN JSON file to continue training or run in inference-only mode.</p>
                <form id="import-qnn-form">
                    <label for="qnn-file-input">Select QNN File</label>
                    <input type="file" id="qnn-file-input" accept=".json">
                </form>
                <div id="imported-qnn-info" class="hidden">
                    <p><strong>File Loaded:</strong> <span id="loaded-filename"></span></p>
                    <p>A QNN file has been loaded. You can modify the prompt below. Then, choose an execution mode:</p>
                    <div id="inference-options">
                        <button id="inference-continue-training-btn" hidden>Continue Training</button>
                        <button id="inference-only-btn">Run Inference Only</button>
                    </div>
                </div>
            </div>

            <div id="graph-architecture" class="section">
                <h2>Graph Architecture</h2>
                <form id="graph-params-form">
                    <div id="debug-options" style="display: flex; gap: 2rem; margin-bottom: 1rem; margin-top: 0.5rem;">
                        <div class="mbti-option">
                            <input type="checkbox" id="debug_mode" name="debug_mode" value="true">
                            <label for="debug_mode">ðŸš€ Enable Debug Mode (Text)</label>
                        </div>
                        <div class="mbti-option">
                            <input type="checkbox" id="coder_debug_mode" name="coder_debug_mode" value="true">
                            <label for="coder_debug_mode">ðŸ’» Enable Coder Debug (Code)</label>
                        </div>
                    </div>

                    <label for="cot_trace_depth">CoT trace depth (max 32):</label>
                    <input type="number" id="cot_trace_depth" name="cot_trace_depth" value="2" max="32" min="2"
                        required>
                    <label for="num_questions">Number of questions for final report (5-100):</label>
                    <input type="number" id="num_questions" name="num_questions" value="25" min="5" max="100" required>
                    <label for="num_epochs">Number of epochs:</label>
                    <input type="number" id="num_epochs" name="num_epochs" value="1" required>
                    <label for="vector_word_size">Vector word size (Number of verbs per agent):</label>
                    <input type="number" id="vector_word_size" name="vector_word_size" value="2" min="2" max="20"
                        required>
                    <label for="prompt_alignment">Prompt alignment (0.1-2.0):</label>
                    <input type="number" id="prompt_alignment" name="prompt_alignment" step="0.1" min="0.1" max="2.0"
                        value="1.0" required>
                    <label for="density">Density (0.1-2.0):</label>
                    <input type="number" id="density" name="density" step="0.1" min="0.1" max="2.0" value="1.0"
                        required>
                    <label for="learning_rate">Learning rate (0.1-2.0):</label>
                    <input type="number" id="learning_rate" name="learning_rate" step="0.1" min="0.1" max="2.0"
                        value="0.1" required>
                    <label>MBTI Archetypes (select at least 2):</label>
                    <div class="mbti-grid">
                        <div class="mbti-option"><input type="checkbox" id="mbti-istj" name="mbti_archetypes"
                                value="ISTJ" checked><label for="mbti-istj">ISTJ (Inspector)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-isfj" name="mbti_archetypes"
                                value="ISFJ" checked><label for="mbti-isfj">ISFJ (Protector)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-infj" name="mbti_archetypes"
                                value="INFJ"><label for="mbti-infj">INFJ (Advocate)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-intj" name="mbti_archetypes"
                                value="INTJ"><label for="mbti-intj">INTJ (Architect)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-istp" name="mbti_archetypes"
                                value="ISTP"><label for="mbti-istp">ISTP (Virtuoso)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-isfp" name="mbti_archetypes"
                                value="ISFP"><label for="mbti-isfp">ISFP (Adventurer)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-infp" name="mbti_archetypes"
                                value="INFP"><label for="mbti-infp">INFP (Mediator)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-intp" name="mbti_archetypes"
                                value="INTP"><label for="mbti-intp">INTP (Logician)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-estp" name="mbti_archetypes"
                                value="ESTP"><label for="mbti-estp">ESTP (Entrepreneur)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-esfp" name="mbti_archetypes"
                                value="ESFP"><label for="mbti-esfp">ESFP (Entertainer)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-enfp" name="mbti_archetypes"
                                value="ENFP"><label for="mbti-enfp">ENFP (Campaigner)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-entp" name="mbti_archetypes"
                                value="ENTP"><label for="mbti-entp">ENTP (Debater)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-estj" name="mbti_archetypes"
                                value="ESTJ"><label for="mbti-estj">ESTJ (Executive)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-esfj" name="mbti_archetypes"
                                value="ESFJ"><label for="mbti-esfj">ESFJ (Consul)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-enfj" name="mbti_archetypes"
                                value="ENFJ"><label for="mbti-enfj">ENFJ (Protagonist)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-entj" name="mbti_archetypes"
                                value="ENTJ"><label for="mbti-entj">ENTJ (Commander)</label></div>
                    </div>
                    <label for="prompt">Prompt:</label>
                    <textarea id="prompt" name="prompt" required>


                    Current diffusers and transformer architectures use integral samplers or differential solvers in the case of diffusers, and decoding algorithms which account as integral, in the case of transformers, to run inference. I presume the foundation of training and architecture are allready figured out, so i want you to create a new inference algorithm that helps exsiting architectures acheive AGI. For this conceptualziation assume the world is full of spinning wheels (harmonic oscillators), like we see them in atoms, solar systems, galaxies, human hierarchies...etc, and data represents a measured state of the "wheel" at a given time. Abudant training data samples the full state of the "wheel" by offering all the posible data of the wheel full state. This is where understanding is reached: by spinning the whole wheel and assimilating all possible perspectives. Current inference algoritms on the other hand, are not fully decoding the internal "implicit wheels" abstracted into the weights after training, as their responses can be shallow. The training algorithms encode the wheels but inference algorithms do not extract them very well. I want you to make in python with excellent documentation: 1. An inference algorithm to achieve AGI through better inference using a PID like approach with perturbative feedback. Instead of just using either an integrative or differential component, i want you to implement both with proportional weighting terms. Figure out a good way to integrate PID loops into transformer inference so transformers learn on inference. 2. a gradio app to monitor the algorithm during an inference run on a mocked transformer which should be built to be sufficiently dense to provide realistic output/input.


                </textarea>
                    <button type="submit" id="run-button">Build and Run Graph</button>
                </form>
            </div>
        </div>

        <div class="container" id="diagnostic-chat-container">
            <div class="header-with-button">
                <h2>Live Diagnostic Chat</h2>
            </div>
            <div id="diagnostic-chat-messages" class="chat-messages"></div>
            <form id="diagnostic-chat-form">
                <textarea id="diagnostic-chat-input" placeholder="Waiting for graph to start..." required
                    disabled></textarea>
                <button type="submit" id="diagnostic-chat-send-button" disabled>Query</button>
            </form>
        </div>



        <div class="container hidden" id="chat-container">
            <div class="header-with-button">
                <h2>Train the interrogator: ask what you want to know, and it will appear in the final report</h2>
                <div style="display: flex; gap: 1rem;">
                    <button id="harvest-button">HARVEST</button>
                </div>
            </div>
            <div id="chat-messages" class="chat-messages"></div>
            <form id="chat-form">
                <textarea id="chat-input" placeholder="Ask a question about the final generated knowledge..."
                    required></textarea>
                <button type="submit" id="chat-send-button">Send</button>
            </form>
        </div>

        <div class="container hidden" id="report-container">
            <h2>Final Report</h2>
            <p>The graph execution is complete. The generated academic papers have been compiled into a single zip
                archive
                for you to download.</p>
            <button id="download-report-button">Download Full Report (.zip)</button>
        </div>

        <div class="container hidden" id="code-result-container">
            <h2>Generated Code</h2>
            <p>The graph execution is complete. The following code has been generated based on your request.</p>
            <pre><code id="code-output" class="language-python"></code></pre>
            <h3>Reasoning:</h3>
            <p id="code-reasoning" style="white-space: pre-wrap;"></p>
        </div>

        <div class="container hidden" id="modules-container">
            <h2>Successfully Built Modules</h2>
            <p>The following modules were successfully synthesized and executed during the run.</p>
            <div id="modules-output"></div>
        </div>

        <button id="export-qnn-button" class="hidden">Export QNN</button>
    </div>
    </div>
    <!-- End Algorithm Design Mode Container -->

    <!-- Shared Visualization Containers -->
    <div class="container" id="perplexity-chart-container">
        <h2>Average Perplexity per Epoch</h2>
        <canvas id="perplexityChart"></canvas>
    </div>

    <div class="container">
        <div class="header-with-button">
            <h2>Real-time Graph Activity</h2>
            <div id="token-display"
                style="background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; font-family: monospace; font-size: 0.9rem; color: #aaa; border: 1px solid #333; display: flex; gap: 10px;">
                <span>Total: <b id="tokens-total" style="color: #fff;">0</b></span>
                <span style="font-size: 0.8em; color: #777;">(In: <span id="tokens-prompt">0</span> Out: <span
                        id="tokens-completion">0</span>)</span>
            </div>
            <button id="download-log-button" disabled>Download Full Log</button>
        </div>
        <div id="log-container"></div>
    </div>

    <div class="container">
        <h2>Graph Visualization</h2>
        <div id="graph-container">
            <p>ASCII graph will be displayed here after the process starts...</p>
        </div>
    </div>

    <script>
        const graphParamsForm = document.getElementById('graph-params-form');
        const runButton = document.getElementById('run-button');
        const logContainer = document.getElementById('log-container');
        const graphContainer = document.getElementById('graph-container');
        const ollamaModelSection = document.getElementById('ollama-model-section');
        const debugModeCheckbox = document.getElementById('debug_mode');
        const coderDebugModeCheckbox = document.getElementById('coder_debug_mode');
        const downloadLogButton = document.getElementById('download-log-button');
        const reportContainer = document.getElementById('report-container');
        const downloadReportButton = document.getElementById('download-report-button');
        const perplexityChartContainer = document.getElementById('perplexity-chart-container');
        const perplexityChartCanvas = document.getElementById('perplexityChart').getContext('2d');
        const graphArchitectureSection = document.getElementById('graph-architecture');

        const chatContainer = document.getElementById('chat-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        const harvestButton = document.getElementById('harvest-button');

        const diagnosticChatContainer = document.getElementById('diagnostic-chat-container');
        const diagnosticChatMessages = document.getElementById('diagnostic-chat-messages');
        const diagnosticChatForm = document.getElementById('diagnostic-chat-form');
        const diagnosticChatInput = document.getElementById('diagnostic-chat-input');

        const codeResultContainer = document.getElementById('code-result-container');
        const codeOutput = document.getElementById('code-output');
        const codeReasoning = document.getElementById('code-reasoning');

        const modulesContainer = document.getElementById('modules-container');
        const modulesOutput = document.getElementById('modules-output');

        const qnnImportContainer = document.getElementById('qnn-import-container');
        const qnnFileInput = document.getElementById('qnn-file-input');
        const importedQnnInfo = document.getElementById('imported-qnn-info');
        const loadedFilename = document.getElementById('loaded-filename');
        const inferenceContinueTrainingBtn = document.getElementById('inference-continue-training-btn');
        const inferenceOnlyBtn = document.getElementById('inference-only-btn');
        const exportQnnButton = document.getElementById('export-qnn-button');

        let fullLogContent = '';
        let perplexityChart = null;
        let allPerplexityValues = [];
        let allLbelsData = [];
        let currentSessionId = null;
        let importedSessionId = null;
        let importedStateContent = null;

        // Brainstorm mode state - chat history and document context
        let brainstormChatHistory = [];  // Array of {role: 'user'|'assistant', content: string}
        let brainstormDocumentContext = '';  // Combined extracted text from PDFs
        let attachedDocuments = [];  // Array of {filename: string, charCount: number}

        // PDF upload elements
        const pdfFileInput = document.getElementById('pdf-file-input');
        const pdfUploadStatus = document.getElementById('pdf-upload-status');
        const clearPdfsBtn = document.getElementById('clear-pdfs-btn');
        const attachedDocumentsList = document.getElementById('attached-documents-list');
        const documentsList = document.getElementById('documents-list');

        // PDF Upload Handler
        pdfFileInput.addEventListener('change', async (e) => {
            const files = e.target.files;
            if (!files.length) return;

            pdfUploadStatus.textContent = 'Uploading...';
            pdfUploadStatus.style.color = '#888';

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                formData.append('files', files[i]);
            }

            try {
                const response = await fetch('/upload_documents', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok) {
                    const newDocs = result.documents || [];
                    let addedCount = 0;

                    // Append new unique documents
                    newDocs.forEach(doc => {
                        if (!attachedDocuments.some(existing => existing.filename === doc.filename)) {
                            attachedDocuments.push(doc);
                            addedCount++;
                        }
                    });

                    // Re-build context from all attached documents
                    brainstormDocumentContext = attachedDocuments.map(d => `[Document: ${d.filename}]\n${d.text}`).join('\n\n---\n\n');

                    const totalChars = attachedDocuments.reduce((sum, doc) => sum + doc.char_count, 0);

                    if (addedCount > 0) {
                        pdfUploadStatus.textContent = `âœ“ Added ${addedCount} new document(s). Total: ${attachedDocuments.length} (${totalChars} chars)`;
                        pdfUploadStatus.style.color = '#28a745';
                    } else {
                        pdfUploadStatus.textContent = `âš  Documents already attached. Total: ${attachedDocuments.length}`;
                        pdfUploadStatus.style.color = '#e0a800';
                    }

                    // Update documents list display
                    documentsList.innerHTML = '';
                    attachedDocuments.forEach(doc => {
                        const badge = document.createElement('span');
                        badge.style.cssText = 'background: #262730; padding: 4px 10px; border-radius: 20px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;';
                        badge.innerHTML = `ðŸ“„ ${doc.filename} <span style="color: #666;">(${doc.char_count} chars)</span>`;
                        documentsList.appendChild(badge);
                    });

                    attachedDocumentsList.style.display = 'block';
                    clearPdfsBtn.style.display = 'inline-block';

                } else {
                    pdfUploadStatus.textContent = `Error: ${result.message}`;
                    pdfUploadStatus.style.color = '#ff4b4b';
                }
            } catch (error) {
                pdfUploadStatus.textContent = `Error: ${error.message}`;
                pdfUploadStatus.style.color = '#ff4b4b';
            }

            // Clear the input for re-selection
            pdfFileInput.value = '';
        });

        // Clear PDFs button handler
        clearPdfsBtn.addEventListener('click', () => {
            brainstormDocumentContext = '';
            attachedDocuments = [];
            documentsList.innerHTML = '';
            attachedDocumentsList.style.display = 'none';
            clearPdfsBtn.style.display = 'none';
            pdfUploadStatus.textContent = '';
        });

        // Mode switching and API key elements
        const modeTabs = document.querySelectorAll('.mode-tab');
        const algorithmMode = document.getElementById('algorithm-mode');
        const brainstormMode = document.getElementById('brainstorm-mode');
        const geminiApiKeyInput = document.getElementById('gemini-api-key');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const apiKeyStatus = document.getElementById('api-key-status');
        const brainstormChat = document.getElementById('brainstorm-chat');
        const brainstormForm = document.getElementById('brainstorm-form');
        const brainstormInput = document.getElementById('brainstorm-input');
        const llmProviderSelect = document.getElementById('llm-provider');
        const geminiConfig = document.getElementById('gemini-config');
        const grokConfig = document.getElementById('grok-config');
        const ollamaConfig = document.getElementById('ollama-config');
        const ollamaModelGlobal = document.getElementById('ollama-model-global');

        // Load settings from localStorage on page load
        const savedProvider = localStorage.getItem('llm_provider') || 'gemini';
        const savedApiKey = localStorage.getItem('gemini_api_key');
        const savedGrokApiKey = localStorage.getItem('grok_api_key');
        const savedOllamaModel = localStorage.getItem('ollama_model');

        llmProviderSelect.value = savedProvider;
        if (savedApiKey) geminiApiKeyInput.value = savedApiKey;
        if (savedGrokApiKey) document.getElementById('grok-api-key').value = savedGrokApiKey;
        if (savedOllamaModel) ollamaModelGlobal.value = savedOllamaModel;

        // Show/hide config based on provider
        const updateProviderConfig = () => {
            if (llmProviderSelect.value === 'gemini') {
                geminiConfig.style.display = 'flex';
                grokConfig.style.display = 'none';
                ollamaConfig.style.display = 'none';
            } else if (llmProviderSelect.value === 'grok') {
                geminiConfig.style.display = 'none';
                grokConfig.style.display = 'flex';
                ollamaConfig.style.display = 'none';
            } else {
                geminiConfig.style.display = 'none';
                grokConfig.style.display = 'none';
                ollamaConfig.style.display = 'flex';
            }
        };
        updateProviderConfig();

        if (savedApiKey || savedOllamaModel) {
            apiKeyStatus.textContent = 'âœ“ Saved';
        }

        // Handle provider change
        llmProviderSelect.addEventListener('change', updateProviderConfig);

        // Save all settings to localStorage
        saveApiKeyBtn.addEventListener('click', () => {
            const provider = llmProviderSelect.value;
            const apiKey = geminiApiKeyInput.value.trim();
            const grokApiKey = document.getElementById('grok-api-key').value.trim();
            const ollamaModel = ollamaModelGlobal.value.trim();

            localStorage.setItem('llm_provider', provider);
            if (apiKey) localStorage.setItem('gemini_api_key', apiKey);
            if (grokApiKey) localStorage.setItem('grok_api_key', grokApiKey);
            if (ollamaModel) localStorage.setItem('ollama_model', ollamaModel);

            apiKeyStatus.textContent = 'âœ“ Saved';
            setTimeout(() => { apiKeyStatus.textContent = ''; }, 2000);
        });

        // Mode tab switching
        modeTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                modeTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const mode = tab.dataset.mode;
                if (mode === 'algorithm') {
                    algorithmMode.classList.remove('hidden');
                    brainstormMode.classList.remove('active');
                } else {
                    algorithmMode.classList.add('hidden');
                    brainstormMode.classList.add('active');
                }
            });
        });

        // Brainstorming mode handler
        const handleBrainstormSubmit = async (e) => {
            e.preventDefault();
            const message = brainstormInput.value.trim();
            const provider = localStorage.getItem('llm_provider') || 'gemini';
            const apiKey = localStorage.getItem('gemini_api_key');
            const grokApiKey = localStorage.getItem('grok_api_key');
            const ollamaModel = localStorage.getItem('ollama_model') || 'dengcao/Qwen3-30B-A3B-Instruct-2507:latest';

            if (!message) return;
            if (provider === 'gemini' && !apiKey) {
                alert('Please save your Gemini API key in the settings panel first.');
                return;
            }
            if (provider === 'grok' && !grokApiKey) {
                alert('Please save your Grok API key in the settings panel first.');
                return;
            }

            // Lock UI
            brainstormInput.disabled = true;
            document.getElementById('brainstorm-send-btn').disabled = true;

            // Add user message to chat history BEFORE sending
            brainstormChatHistory.push({
                role: 'user',
                content: message
            });

            // Clear input and show message
            brainstormInput.value = '';
            logContainer.innerHTML = ''; // Start fresh
            fullLogContent = '';

            // Add to Brainstorm Chat
            const chatDiv = document.getElementById('brainstorm-chat');
            // Remove placeholder if exists
            if (chatDiv.children[0] && chatDiv.children[0].innerText.includes('Ask a question')) {
                chatDiv.innerHTML = '';
            }

            const userMsgDiv = document.createElement('div');
            userMsgDiv.style.cssText = "background: #334; padding: 1rem; margin: 0.5rem 0; border-radius: 8px; border-left: 4px solid #a0a0ff;";
            userMsgDiv.innerHTML = `<strong>User:</strong> ${message}`;
            chatDiv.appendChild(userMsgDiv);
            chatDiv.scrollTop = chatDiv.scrollHeight;

            // Hide Graph for Brainstorm
            graphContainer.parentElement.style.display = 'none';

            addLogMessage(`<strong>User:</strong> ${message}`, { isHTML: true, color: '#a0a0ff' });

            // Prepare params for build_and_run_graph
            // We map 'message' to 'prompt'
            const params = {
                prompt: message,
                provider: provider,
                api_key: provider === 'grok' ? grokApiKey : apiKey, // Send the correct key
                ollama_model: ollamaModel,
                // Defaults for Brainstorm mode (backend determines complexities, but we can pass explicit overrides if we had UI for them)
                // Passing reasonable defaults just in case backend needs them for fallback
                vector_word_size: 2,
                prompt_alignment: 1.0,
                density: 1.0,
                learning_rate: 0.1,
                num_epochs: document.getElementById('brainstorm_epochs').value || 2,
                debug_mode: document.getElementById('brainstorm_debug_mode').checked ? 'true' : 'false'
            };

            try {
                // Call runGraph with mode='brainstorm', including chat history and document context
                // runGraph handles log clearing, SSE connection, etc.
                await runGraph({
                    params: params,
                    mode: 'brainstorm',
                    chat_history: brainstormChatHistory,
                    document_context: brainstormDocumentContext
                }, '/build_and_run_graph', false); // Do not clear logs again

            } catch (error) {
                addLogMessage(`Error initiating brainstorming: ${error.message}`, { color: 'red' });
            } finally {
                brainstormInput.disabled = false;
                document.getElementById('brainstorm-send-btn').disabled = false;
                brainstormInput.focus();
            }
        };

        brainstormForm.addEventListener('submit', handleBrainstormSubmit);
        brainstormInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                brainstormForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
            }
        });


        const handleDebugCheck = (e) => {
            const isDebug = debugModeCheckbox.checked || coderDebugModeCheckbox.checked;
            ollamaModelSection.classList.toggle('hidden', isDebug);

            if (e.target.id === 'debug_mode' && e.target.checked) {
                coderDebugModeCheckbox.checked = false;
            } else if (e.target.id === 'coder_debug_mode' && e.target.checked) {
                debugModeCheckbox.checked = false;
            }
        };

        debugModeCheckbox.addEventListener('change', handleDebugCheck);
        coderDebugModeCheckbox.addEventListener('change', handleDebugCheck);

        const addLogMessage = (text, options = {}) => {
            fullLogContent += text + '\n';
            if (downloadLogButton.disabled) {
                downloadLogButton.disabled = false;
            }
            const container = document.createElement('div');
            container.style.margin = '0';
            container.style.lineHeight = '1.4';

            if (options.isHTML) {
                container.innerHTML = text;
            } else {
                container.textContent = text;
            }

            if (options.color) container.style.color = options.color;

            logContainer.appendChild(container);
            logContainer.scrollTop = logContainer.scrollHeight;
        };

        const downloadLog = () => {
            const blob = new Blob([fullLogContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.download = `noa-run-log-${timestamp}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        downloadLogButton.addEventListener('click', downloadLog);

        const renderPerplexityChart = () => {
            if (perplexityChart) {
                perplexityChart.destroy();
            }
            const labels = allLbelsData;
            const data = allPerplexityValues;

            perplexityChart = new Chart(perplexityChartCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Average Agent Perplexity',
                        data: data,
                        borderColor: 'rgba(255, 75, 75, 1)',
                        backgroundColor: 'rgba(255, 75, 75, 0.2)',
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Perplexity Score' }
                        },
                        x: {
                            title: { display: true, text: 'Epoch' }
                        }
                    }
                }
            });
        };

        const handleChatSubmit = async (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (!message || !currentSessionId) return;

            const userMsgDiv = document.createElement('div');
            userMsgDiv.className = 'chat-message user-message';
            userMsgDiv.textContent = message;
            chatMessages.appendChild(userMsgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            chatInput.value = '';
            chatInput.disabled = true;

            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = 'chat-message ai-message';
            aiMsgDiv.textContent = '...';
            chatMessages.appendChild(aiMsgDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: currentSessionId, message: message })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    aiMsgDiv.textContent = `Error: ${errorText}`;
                    return;
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let aiResponseText = '';
                aiMsgDiv.textContent = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    aiResponseText += chunk;
                    aiMsgDiv.innerHTML = marked.parse(aiResponseText);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            } catch (error) {
                aiMsgDiv.textContent = `Error: ${error.message}`;
            } finally {
                chatInput.disabled = false;
                chatInput.focus();
            }
        };

        const handleDiagnosticChatSubmit = async (e) => {
            e.preventDefault();
            const message = diagnosticChatInput.value.trim();
            if (!message || !currentSessionId) return;

            const userMsgDiv = document.createElement('div');
            userMsgDiv.className = 'chat-message diagnostic-user-message';
            userMsgDiv.textContent = message;
            diagnosticChatMessages.appendChild(userMsgDiv);
            diagnosticChatMessages.scrollTop = diagnosticChatMessages.scrollHeight;

            diagnosticChatInput.value = '';
            diagnosticChatInput.disabled = true;

            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = 'chat-message diagnostic-ai-message';
            aiMsgDiv.textContent = '...';
            diagnosticChatMessages.appendChild(aiMsgDiv);
            diagnosticChatMessages.scrollTop = diagnosticChatMessages.scrollHeight;

            try {
                const response = await fetch('/diagnostic_chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: currentSessionId, message: message })
                });
                if (!response.ok) {
                    const errorText = await response.text();
                    aiMsgDiv.textContent = `Error: ${errorText}`;
                    return;
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let aiResponseText = '';
                aiMsgDiv.textContent = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value, { stream: true });
                    aiResponseText += chunk;
                    aiMsgDiv.innerHTML = marked.parse(aiResponseText);
                    diagnosticChatMessages.scrollTop = diagnosticChatMessages.scrollHeight;
                }
            } catch (error) {
                aiMsgDiv.textContent = `Error: ${error.message}`;
            } finally {
                diagnosticChatInput.disabled = false;
                diagnosticChatInput.focus();
            }
        };

        const handleHarvestClick = async () => {
            if (!currentSessionId) return;

            harvestButton.disabled = true;
            chatInput.disabled = true;
            harvestButton.textContent = 'Harvesting...';
            addLogMessage(`--- [HARVEST] User initiated final harvest for session ${currentSessionId} ---`, { color: 'yellow' });

            try {
                const response = await fetch('/harvest', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: currentSessionId })
                });
                const result = await response.json();

                if (!response.ok) {
                    addLogMessage(`Error during harvest: ${result.message}`, { color: 'red' });
                    if (result.traceback) {
                        addLogMessage(result.traceback, { isHTML: false });
                    }
                    return;
                }

                addLogMessage(`<strong>âœ… ${result.message}</strong>`, { isHTML: true, color: 'lime' });

                if (result.message === "Harvest complete.") {
                    addLogMessage(`Report generated successfully. Session ID: ${currentSessionId}`, { color: 'cyan' });
                    reportContainer.classList.remove('hidden');
                    downloadReportButton.onclick = () => {
                        window.location.href = `/download_report/${currentSessionId}`;
                    };
                } else {
                    addLogMessage(`âš ï¸ Server finished but no downloadable report was generated.`, { color: 'orange' });
                }

                chatContainer.classList.add('hidden');
                graphArchitectureSection.classList.remove('hidden');
                qnnImportContainer.classList.remove('hidden');

            } catch (error) {
                addLogMessage(`Client-side error during harvest: ${error.message}`, { color: 'red' });
            } finally {
                harvestButton.disabled = false;
                harvestButton.textContent = 'HARVEST';
                runButton.disabled = false;
                runButton.textContent = 'Build and Run Graph';
            }
        };

        function parseJsonFromDataString(inputString) {
            const jsonString = inputString.slice(5, inputString.length);
            try {
                return JSON.parse(jsonString);
            } catch (error) {
                console.error("Failed to parse JSON from event stream:", error, "String was:", jsonString);
                return null;
            }
        }

        async function runGraph(payload, endpointUrl, clearLogs = true) {
            runButton.disabled = true;
            runButton.textContent = 'Processing...';
            downloadLogButton.disabled = true;
            if (clearLogs) {
                logContainer.innerHTML = '';
                fullLogContent = '';
            }
            graphContainer.innerHTML = '<p>ASCII graph will be displayed here after the process starts...</p>';

            reportContainer.classList.add('hidden');
            codeResultContainer.classList.add('hidden');
            modulesContainer.classList.add('hidden');
            chatContainer.classList.add('hidden');
            graphArchitectureSection.classList.add('hidden');
            qnnImportContainer.classList.add('hidden');

            diagnosticChatMessages.innerHTML = '';
            allPerplexityValues = [];
            allLbelsData = [];
            renderPerplexityChart();
            addLogMessage(`Sending request to endpoint: ${endpointUrl}`);

            try {
                const response = await fetch(endpointUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();


                if (!response.ok) {
                    addLogMessage(`Error: ${result.message}`, { color: 'red' });
                    if (result.traceback) {
                        const pre = document.createElement('pre');
                        pre.style.color = '#ff8c8c';
                        pre.textContent = result.traceback;
                        logContainer.appendChild(pre);
                    }
                } else if (result.code_solution) {

                    let codeToDisplay = result.code_solution;

                    const codeMatch = /```(?:python\n)?([\s\S]*?)```/.exec(codeToDisplay);
                    if (codeMatch) {
                        codeToDisplay = codeMatch[1].trim();
                    }

                    codeToDisplay = codeToDisplay.replace(/\\n/g, '\n').replace(/\\"/g, '"');

                    codeOutput.textContent = codeToDisplay;
                    Prism.highlightElement(codeOutput);
                    codeReasoning.textContent = result.reasoning;
                    codeResultContainer.classList.remove('hidden');
                    exportQnnButton.classList.remove('hidden');

                    if (result.modules && Array.isArray(result.modules) && result.modules.length > 0) {
                        addLogMessage(`Rendering ${result.modules.length} successfully built modules.`, { color: 'cyan' });
                        modulesOutput.innerHTML = '';
                        result.modules.forEach((module, index) => {
                            const moduleDiv = document.createElement('div');
                            moduleDiv.style.marginBottom = '2rem';
                            const cardHeader = document.createElement('h3');
                            cardHeader.textContent = `Module ${index + 1}: Interface Card`;
                            const cardPre = document.createElement('pre');
                            cardPre.textContent = module.card;
                            cardPre.style.cssText = 'background-color:#1C1E25; padding:1rem; border-radius:var(--border-radius); white-space:pre-wrap;';
                            const codeHeader = document.createElement('h3');
                            codeHeader.textContent = `Module ${index + 1}: Source Code`;
                            const codePre = document.createElement('pre');
                            const codeElem = document.createElement('code');
                            codeElem.className = 'language-python';
                            let codeModule = "";
                            const codeMatch = /```(?:python\n)?([\s\S]*?)```/.exec(module.code);
                            if (codeMatch) {
                                codeModule = codeMatch[1].trim();
                            }

                            codeToDisplay = codeModule.replace(/\\n/g, '\n').replace(/\\"/g, '"');
                            codeElem.textContent = codeToDisplay;
                            codePre.appendChild(codeElem);
                            moduleDiv.append(cardHeader, cardPre, codeHeader, codePre);
                            modulesOutput.appendChild(moduleDiv);
                            Prism.highlightElement(codeElem);
                        });
                        modulesContainer.classList.remove('hidden');

                    }


                } else if (result.message === "Chat is now active.") {
                    addLogMessage(`<strong>âœ… ${result.message}</strong>`, { isHTML: true, color: 'lime' });
                    currentSessionId = result.session_id;
                    diagnosticChatContainer.classList.add('hidden');
                    chatContainer.classList.remove('hidden');
                    chatContainer.focus();

                    exportQnnButton.classList.remove('hidden');
                } else {
                    addLogMessage(`Error: Unexpected response from server: ${JSON.stringify(result)}`, { color: 'red' });
                    graphArchitectureSection.classList.remove('hidden');
                    qnnImportContainer.classList.remove('hidden');
                }
            } catch (error) {
                addLogMessage(`A client-side error occurred: ${error.message}`, { color: 'red' });
                graphArchitectureSection.classList.remove('hidden');
                qnnImportContainer.classList.remove('hidden');
            } finally {

            }
        }

        graphParamsForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            // Ensure graph is visible
            graphContainer.parentElement.style.display = 'block';

            const formData = new FormData(graphParamsForm);
            const params = {};
            formData.forEach((value, key) => {
                if (key === 'mbti_archetypes') {
                    if (!params[key]) params[key] = [];
                    params[key].push(value);
                } else {
                    params[key] = value;
                }
            });
            if (!formData.has('debug_mode')) params.debug_mode = 'false';
            if (!formData.has('coder_debug_mode')) params.coder_debug_mode = 'false';
            if (!params.mbti_archetypes || params.mbti_archetypes.length < 2) {
                alert('Please select at least 2 MBTI archetypes.');
                return;
            }

            // Include Global Provider Settings
            const provider = document.getElementById('llm-provider').value;
            const geminiKey = document.getElementById('gemini-api-key').value.trim();
            const grokKey = document.getElementById('grok-api-key').value.trim();
            const ollamaGlobal = document.getElementById('ollama-model-global').value.trim();

            params.provider = provider;
            if (provider === 'gemini') params.api_key = geminiKey;
            if (provider === 'grok') params.api_key = grokKey;
            params.ollama_model = ollamaGlobal;

            runGraph({ params }, '/build_and_run_graph');
        });

        qnnFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                importedStateContent = null;
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    importedStateContent = event.target.result;
                    const parsedState = JSON.parse(importedStateContent);

                    loadedFilename.textContent = file.name;

                    const uploadFormData = new FormData();
                    uploadFormData.append('file', file);
                    fetch('/import_qnn', { method: 'POST', body: uploadFormData })
                        .then(res => res.json())
                        .then(result => {
                            if (result.session_id) {
                                importedSessionId = result.session_id;
                                addLogMessage(`QNN '${file.name}' staged for 'Continue Training'. Session: ${importedSessionId}`, { color: 'cyan' });
                            }
                        });

                    if (parsedState.params) {
                        Object.keys(parsedState.params).forEach(key => {
                            const input = graphParamsForm.querySelector(`[name="${key}"]`);
                            if (input && input.type === 'checkbox') {
                                input.checked = parsedState.params[key] === 'true';
                            } else if (input) {
                                input.value = parsedState.params[key];
                            }
                        });
                        if (parsedState.params.mbti_archetypes) {
                            document.querySelectorAll('input[name="mbti_archetypes"]').forEach(cb => {
                                cb.checked = parsedState.params.mbti_archetypes.includes(cb.value);
                            });
                        }
                    }

                    importedQnnInfo.classList.remove('hidden');
                    graphArchitectureSection.classList.add('hidden');

                } catch (error) {
                    alert(`Error parsing QNN file: ${error.message}`);
                    importedStateContent = null;
                }
            };
            reader.readAsText(file);
        });

        const startContinueTrainingRun = () => {
            if (!importedSessionId) {
                alert("No imported session staged for training. Please re-select the file.");
                return;
            }
            const formData = new FormData(graphParamsForm);
            const params = {};
            formData.forEach((value, key) => {
                if (key === 'mbti_archetypes') {
                    if (!params[key]) params[key] = [];
                    params[key].push(value);
                } else {
                    params[key] = value;
                }
            });
            runGraph({ params: params, session_id_to_load: importedSessionId }, '/build_and_run_graph');
        };

        const startInferenceOnlyRun = () => {
            if (!importedStateContent) {
                alert("No QNN file content loaded. Please select a file.");
                return;
            }

            const newPrompt = prompt("Please enter the prompt for the inference-only run:", document.getElementById('prompt').value);

            if (!newPrompt || !newPrompt.trim()) {
                alert("A prompt is required to run inference. Operation cancelled.");
                return;
            }

            const payload = {
                imported_state: JSON.parse(importedStateContent),
                prompt: newPrompt
            };
            runGraph(payload, '/run_inference_from_state');
        };



        inferenceContinueTrainingBtn.addEventListener('click', startContinueTrainingRun);
        inferenceOnlyBtn.addEventListener('click', startInferenceOnlyRun);

        exportQnnButton.addEventListener('click', () => {
            if (currentSessionId) {
                window.location.href = `/export_qnn/${currentSessionId}`;
            } else {
                alert("No active session to export.");

            }

        }

        );

        const eventSource = new EventSource('/stream_log');

        eventSource.onmessage = function (event) {
            const rawMessage = event.data;

            if (rawMessage.includes('epoch') && rawMessage.includes('perplexity')) {

                data = parseJsonFromDataString(rawMessage);
                addLogMessage(`>>> Perplexity data received for epoch ${data.epoch}: ${data.perplexity.toFixed(2)}`, { color: 'cyan' });
                allPerplexityValues.push(parseFloat(data.perplexity));
                allLbelsData.push(data.epoch);
                renderPerplexityChart();

            } else if (rawMessage.includes('TOKEN_USAGE:')) {
                try {
                    const token = 'TOKEN_USAGE:';
                    let parts = rawMessage.substring(rawMessage.indexOf(token) + token.length).trim();
                    if (parts.startsWith('"') && parts.endsWith('"') && parts.includes('\\"')) {
                        try { parts = JSON.parse(parts); } catch (e) { }
                    }
                    const usage = JSON.parse(parts);
                    document.getElementById('tokens-total').innerText = usage.total;
                    document.getElementById('tokens-prompt').innerText = usage.prompt;
                    document.getElementById('tokens-completion').innerText = usage.completion;
                } catch (e) { console.error("Token parsing error", e); }
                return;

            } else if (rawMessage.includes('FINAL_ANSWER:')) {
                console.log("Received FINAL_ANSWER event:", rawMessage);
                try {
                    // Extract payload regardless of prefix
                    const token = 'FINAL_ANSWER:';
                    let jsonStr = rawMessage.substring(rawMessage.indexOf(token) + token.length).trim();

                    let answer = JSON.parse(jsonStr);

                    // Handle double-encoding (common with MockLLM -> Backend -> Frontend flow)
                    if (typeof answer === 'string') {
                        try {
                            const parsedSecond = JSON.parse(answer);
                            answer = parsedSecond;
                        } catch (e) {
                            // It was just a string, keep as is
                        }
                    }

                    const chatDiv = document.getElementById('brainstorm-chat');
                    if (chatDiv) {
                        const synthesisMsgDiv = document.createElement('div');
                        synthesisMsgDiv.style.cssText = "background: #1e3a29; padding: 1rem; margin: 0.5rem 0; border-radius: 8px; border-left: 4px solid #28a745; color: #e0e0e0; box-shadow: 0 2px 4px rgba(0,0,0,0.2); font-family: 'Segoe UI', sans-serif;";

                        let displayText = '';
                        if (typeof answer === 'object' && answer !== null) {
                            // Prefer 'proposed_solution' if available
                            if (answer.proposed_solution) displayText = answer.proposed_solution;
                            else displayText = JSON.stringify(answer, null, 2);
                        } else {
                            displayText = String(answer);
                        }


                        // Format formatting
                        // Use marked.parse for markdown rendering
                        try {
                            displayText = marked.parse(displayText);
                        } catch (e) {
                            console.error("Error parsing markdown:", e);
                            // Fallback to basic replacement if marked fails
                            displayText = displayText.replace(/\n/g, '<br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                        }

                        synthesisMsgDiv.innerHTML = `<div style="color: #28a745; font-weight: bold; margin-bottom: 0.5rem;">ðŸ§  Synthesis</div>${displayText}`;
                        chatDiv.appendChild(synthesisMsgDiv);
                        chatDiv.scrollTop = chatDiv.scrollHeight;

                        // Add assistant response to chat history for continuity
                        let rawAnswerText = '';
                        if (typeof answer === 'object' && answer !== null) {
                            rawAnswerText = answer.proposed_solution || JSON.stringify(answer);
                        } else {
                            rawAnswerText = String(answer);
                        }
                        brainstormChatHistory.push({
                            role: 'assistant',
                            content: rawAnswerText
                        });
                    }

                    // Re-enable input
                    const btn = document.getElementById('brainstorm-send-btn');
                    const input = document.getElementById('brainstorm-input');
                    if (btn) { btn.disabled = false; btn.innerText = 'Send'; }
                    if (input) { input.disabled = false; input.focus(); }

                } catch (e) {
                    console.error("Failed to parse FINAL_ANSWER", e);
                    addLogMessage(`Error parsing final answer: ${e.message}`, { color: 'red' });
                }
                addLogMessage(rawMessage);

            } else if (rawMessage.includes('__start__')) {

                graphContainer.textContent = rawMessage.replace('__start__', '');
                addLogMessage(">>> ASCII Graph Rendered <<<", { color: 'cyan' });
            } else if (rawMessage.includes('__session_id__')) {
                session_id = rawMessage.replace('__session_id__', '');
                currentSessionId = session_id.replace('data: ', '').trim();
                const diagInput = document.getElementById('diagnostic-chat-input');
                const diagButton = document.getElementById('diagnostic-chat-send-button');
                diagInput.disabled = false;
                diagButton.disabled = false;
                addLogMessage(`>>> Session ID: ${currentSessionId}`, { color: 'cyan' });
                addLogMessage(`<strong>âœ… Diagnostic chat is now active.</strong>`, { isHTML: true, color: 'lime' });
                diagInput.placeholder = "Live diagnostic rag-chat is active.";
                return;
            } else {

                addLogMessage(rawMessage);
            }

        };

        eventSource.onerror = function (err) {
            console.error("EventSource failed:", err);
            addLogMessage("Error: Connection to server log stream lost. Please refresh and try again.", { color: 'red' });
            eventSource.close();
        };

        chatForm.addEventListener('submit', handleChatSubmit);
        diagnosticChatForm.addEventListener('submit', handleDiagnosticChatSubmit);
        harvestButton.addEventListener('click', handleHarvestClick);

        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                chatForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
            }
        });

        diagnosticChatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                diagnosticChatForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
            }
        });
    </script>
    <script src="js/prism-core.min.js"></script>
    <script src="js/prism-autoloader.min.js"></script>
    <script src="js/prism-toolbar.min.js"></script>
    <script src="js/prism-copy-to-clipboard.min.js"></script>
</body>

</html>